<!--
  ~ Copyright (C) 2011 Emergency CallWorx, Inc. All rights reserved.
  ~
  ~ $Id$
  -->

<!-- $Id: macros.xml 190 2010-07-09 15:56:13Z archie $ -->

<project name="build-macros"
  xmlns:antcontrib="urn:net.sf.antcontrib"
  xmlns:dellroad="urn:org.dellroad.ant"
  xmlns:ivy="urn:org.apache.ivy.ant"
  xmlns:testng="urn:org.testng"
  xmlns:cobertura="urn:net.sf.cobertura"
  xmlns:findbugs="urn:edu.umd.cs.findbugs"
  xmlns:checkstyle="urn:net.sf.checkstyle">

<!--
    Instructions for includers of this file:

    - Define "javac.classpath" target finding classes required for javac and unit test compilation
    - Define "unittest.classpath" target finding additional classes required for unit test execution
    - Override "javac.compiler.flags" if desired

-->

    <!-- Project should override this as necessary -->
    <property name="javac.compiler.flags" value=""/>

<!--
        ************* DETERMINE BASE DIRECTORY ****************
-->

    <dirname property="build.macros.dir" file="${ant.file.build-macros}"/>

<!--
        ************* DEFINE ANTCONTRIB AND IVY STUFF ****************
-->

    <!-- Set variables -->
    <property name="data.dir" value="/usr/share"/>

    <!-- Load environment variables as properties with "environ." prefix -->
    <property environment="environ"/>

    <!-- Find ivy.jar; use IVY_JAR environment variable if set, otherwise fall back to default -->
    <condition property="ivy.jar" value="${environ.IVY_JAR}">
        <isset property="environ.IVY_JAR"/>
    </condition>
    <condition property="ivy.jar" value="${data.dir}/java/ivy.jar">
        <not>
            <isset property="environ.IVY_JAR"/>
        </not>
    </condition>
    <fail message="can't find ivy.jar; please install ${data.dir}/java/ivy.jar or set $IVY_JAR">
        <condition>
            <not>
                <available file="${ivy.jar}"/>
            </not>
        </condition>
    </fail>

    <!-- Import ivy tasks -->
    <taskdef uri="urn:org.apache.ivy.ant" resource="org/apache/ivy/ant/antlib.xml" classpath="${ivy.jar}"/>

    <!-- Find ant-contrib.jar; use ANT_CONTRIB_JAR environment variable if set, otherwise fall back to default -->
    <condition property="ant-contrib.jar" value="${env.ANT_CONTRIB_JAR}">
        <isset property="environ.ANT_CONTRIB_JAR"/>
    </condition>
    <condition property="ant-contrib.jar" value="${data.dir}/java/ant-contrib.jar">
        <not>
            <isset property="environ.ANT_CONTRIB_JAR"/>
        </not>
    </condition>
    <fail message="can't find ant-contrib.jar; please install ${data.dir}/java/ant-contrib.jar or set $ANT_CONTRIB_JAR">
        <condition>
            <not>
                <available file="${ant-contrib.jar}"/>
            </not>
        </condition>
    </fail>

    <!-- Import ant-contrib tasks -->
    <taskdef uri="urn:net.sf.antcontrib" resource="net/sf/antcontrib/antcontrib.properties" classpath="${ant-contrib.jar}"/>

    <!-- Get the sed(1) 'extended regular expression' flag for this O/S ('-E' for BSDish, '-r' for Linux) -->
    <exec outputproperty="sed.extended.flag" executable="/bin/sh" logError="true" failonerror="true">
        <arg value="-c"/>
        <arg value="case `uname -s` in
            Darwin|*BSD)
                printf '%s' -E;
                ;;
            *)
                printf '%s' -r;
                ;;
            esac"/>
    </exec>

<!--
        ************* IVY CONFIGURATION ****************
-->

    <!--
        Macro for resolving a classpath by naming the module, etc. directly.
        Defines classpath "@{pathid}" and sets property "@{pathid}.resolved".
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivymodpath">
        <attribute name="pathid" description="Classpath reference id to define"/>
        <attribute name="org" description="Module organisation name"/>
        <attribute name="mod" description="Module module name"/>
        <attribute name="rev" description="Module revision"/>
        <attribute name="conf" default="default" description="Name of the ivy configuration to resolve"/>
        <attribute name="type" default="jar" description="Type of artifact to resolve"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="transitive" default="true" description="Whether to resolve dependencies transitively"/>
        <attribute name="log" default="download-only" description="When to log activity"/>
        <sequential>
            <ivy:resolve settingsRef="@{settingsRef}" organisation="@{org}" module="@{mod}" revision="@{rev}"
              type="@{type}" inline="true" transitive="@{transitive}" conf="@{conf}" log="@{log}"/>
            <ivy:cachepath settingsRef="@{settingsRef}" organisation="@{org}" module="@{mod}" revision="@{rev}"
              type="@{type}" inline="true" transitive="@{transitive}" conf="@{conf}" log="@{log}" pathid="@{pathid}"/>
            <property name="@{pathid}.resolved" value="true"/>
        </sequential>
    </macrodef>

    <!--
        Macro for resolving a classpath using a named configuration in ivy.xml.
        Defines classpath "@{pathid}" and sets property "@{pathid}.resolved".
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivypath">
        <attribute name="pathid" description="Classpath reference id to define"/>
        <attribute name="ivyfile" default="${basedir}/src/ivy/ivy.xml" description="ivy.xml defining the named configuration"/>
        <attribute name="conf" description="Name of the ivy configuration to resolve"/>
        <attribute name="type" default="jar" description="Type of artifact to resolve"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="transitive" default="true" description="Whether to resolve dependencies transitively"/>
        <attribute name="log" default="download-only" description="When to log activity"/>
        <sequential>
            <ivy:resolve file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}"/>
            <ivy:cachepath file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}" pathid="@{pathid}"/>
            <property name="@{pathid}.resolved" value="true"/>
        </sequential>
    </macrodef>

    <!--
        Macro for resolving a fileset using a named configuration in ivy.xml.
        Defines fileset "@{setid}" and sets property "@{setid}.resolved".
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivyfileset">
        <attribute name="setid" description="Fileset reference id to define"/>
        <attribute name="ivyfile" default="${basedir}/src/ivy/ivy.xml" description="ivy.xml defining the named configuration"/>
        <attribute name="conf" description="Name of the ivy configuration to resolve"/>
        <attribute name="type" default="jar" description="Type of artifact to resolve"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="transitive" default="true" description="Whether to resolve dependencies transitively"/>
        <attribute name="log" default="download-only" description="When to log activity"/>
        <sequential>
            <ivy:resolve file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}"/>
            <ivy:cachefileset file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}" setid="@{setid}"/>
            <property name="@{setid}.resolved" value="true"/>
        </sequential>
    </macrodef>

    <!--
        Macro for retrieving ivy artifacts using a named configuration in ivy.xml.
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivyput">
        <attribute name="pattern" description="Ivy pattern for artifact destination"/>
        <attribute name="ivyfile" default="${basedir}/src/ivy/ivy.xml" description="ivy.xml defining the named configuration"/>
        <attribute name="conf" description="Name of the ivy configuration to resolve"/>
        <attribute name="type" default="jar" description="Type of artifact to resolve"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="transitive" default="true" description="Whether to resolve dependencies transitively"/>
        <attribute name="log" default="download-only" description="When to log activity"/>
        <sequential>
            <ivy:resolve file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}"/>
            <ivy:retrieve file="@{ivyfile}" settingsRef="@{settingsRef}" type="@{type}"
              transitive="@{transitive}" conf="@{conf}" log="@{log}" pattern="@{pattern}"/>
        </sequential>
    </macrodef>

    <!--
        Macro for retrieving artifacts by naming the module, etc. directly.
        Does not require an ivy.xml file.
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivymodget">
        <attribute name="pattern" description="Ivy pattern for artifact destination"/>
        <attribute name="org" description="Module organisation name"/>
        <attribute name="mod" description="Module module name"/>
        <attribute name="rev" description="Module revision"/>
        <attribute name="conf" default="default" description="Name of the ivy configuration to resolve"/>
        <attribute name="type" default="jar" description="Type of artifact to resolve"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="transitive" default="true" description="Whether to resolve dependencies transitively"/>
        <attribute name="log" default="download-only" description="When to log activity"/>
        <sequential>
            <ivy:resolve settingsRef="@{settingsRef}" organisation="@{org}" module="@{mod}" revision="@{rev}"
              type="@{type}" inline="true" transitive="@{transitive}" conf="@{conf}" log="@{log}"/>
            <ivy:retrieve settingsRef="@{settingsRef}" organisation="@{org}" module="@{mod}" revision="@{rev}"
              type="@{type}" inline="true" transitive="@{transitive}" conf="@{conf}" log="@{log}" pattern="@{pattern}"/>
        </sequential>
    </macrodef>

    <!--
        Macro for generating a resolution report for a given configuration.
        Requires a previous <ivy:resolve> operation.
    -->
    <macrodef uri="urn:org.dellroad.ant" name="ivyreport">
        <attribute name="conf" default="default" description="Name of the ivy configuration to report"/>
        <attribute name="destdir" default="build/reports/ivy" description="Directory in which to put generated reports"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <sequential>
            <mkdir dir="@{destdir}"/>
            <ivy:report settingsRef="@{settingsRef}" conf="@{conf}" todir="@{destdir}" xml="true" outputpattern="[conf].[ext]"/>
        </sequential>
    </macrodef>

    <!-- Configure Ivy -->
    <antcontrib:if>
        <available file="${basedir}/src/ivy/settings.xml" type="file"/>
        <antcontrib:then>
            <ivy:settings id="build-macros-ivy-settings" file="${basedir}/src/ivy/settings.xml"/>
        </antcontrib:then>
        <antcontrib:elseif>
            <available file="${data.dir}/ivy/settings.xml" type="file"/>
            <antcontrib:then>
                <ivy:settings id="build-macros-ivy-settings" file="${data.dir}/ivy/settings.xml"/>
            </antcontrib:then>
        </antcontrib:elseif>
        <antcontrib:else>
            <ivy:settings id="build-macros-ivy-settings" file="${build.macros.dir}/ivysettings.xml"/>
        </antcontrib:else>
    </antcontrib:if>

<!--
        ************* MACROS AND PRESETDEFS ****************
-->

    <!-- SVN revision -->
    <macrodef uri="urn:org.dellroad.ant" name="svnrevision">
        <attribute name="property" default="svn.revision" description="Name of property to set"/>
        <attribute name="dir" default="${basedir}" description="Target checked-out SVN directory"/>
        <sequential>
            <exec outputproperty="@{property}" executable="/bin/sh" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="svnversion -c @{dir} | sed ${sed.extended.flag} -e 's/^[0-9]+://g' -e 's/^-1M$/0/g'"/>
            </exec>
        </sequential>
    </macrodef>

    <!-- SuSE version -->
    <macrodef uri="urn:org.dellroad.ant" name="suseversion">
        <attribute name="property" description="Name of property to set"/>
        <sequential>
            <exec outputproperty="@{property}" executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="SREL=`head -1 /etc/SuSE-release`;
                case &quot;$${SREL}&quot; in
                    SUSE\ LINUX\ Enterprise\ Server\ 9\ \(*)
                        echo -n sles9;
                        ;;
                    SUSE\ LINUX\ 10\.0\ \(*)
                        echo -n suse10.0;
                        ;;
                    SUSE\ LINUX\ 10\.1\ \(*)
                        echo -n suse10.1;
                        ;;
                    openSUSE\ [0-9][0-9]\.[0-9]\ \(*)
                        LABEL=`echo &quot;$${SREL}&quot; | sed ${sed.extended.flag} 's|^openSUSE ([0-9]+\.[0-9]+) \(.*$$|\1|g'`;
                        echo -n &quot;$${LABEL}&quot;;
                        ;;
                    *)
                        echo -n unknown;
                        ;;
                esac"/>
            </exec>
        </sequential>
    </macrodef>

    <!-- Check umask -->
    <macrodef uri="urn:org.dellroad.ant" name="checkumask">
        <attribute name="u" default="" description="Required user bits"/>
        <attribute name="g" default="" description="Required group bits"/>
        <attribute name="o" default="" description="Required other bits"/>
        <sequential>
            <exec outputproperty="@{property}" executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    bailout()
                    {
                        echo ERROR: $${1+&quot;$@&quot;} 1>&amp;2;
                        exit 1;
                    };
                    PAT='^u=((r)?(w)?(x)?),g=((r)?(w)?(x)?),o=((r)?(w)?(x)?)$$';
                    UBITS=`umask -S`;
                    echo $${UBITS} | grep -qE &quot;$${PAT}&quot; || bailout failed to parse umask: `umask -S`;
                    [ '@{u}' = '' -o `echo $${UBITS} | sed ${sed.extended.flag} 's|'&quot;$${PAT}&quot;'|\1|g'` = '@{u}' ]
                      || bailout umask must have u='@{u}';
                    [ '@{g}' = '' -o `echo $${UBITS} | sed ${sed.extended.flag} 's|'&quot;$${PAT}&quot;'|\5|g'` = '@{g}' ]
                      || bailout umask must have g='@{g}';
                    [ '@{o}' = '' -o `echo $${UBITS} | sed ${sed.extended.flag} 's|'&quot;$${PAT}&quot;'|\9|g'` = '@{o}' ]
                      || bailout umask must have o='@{o}';
                "/>
            </exec>
        </sequential>
    </macrodef>

    <!-- Generate checksum -->
    <macrodef uri="urn:org.dellroad.ant" name="checksum">
        <attribute name="property" description="Name of property to set"/>
        <attribute name="dirs" default="${basedir}" description="Directories to include (space delimited)"/>
        <attribute name="files" default="" description="Additional file(s) to include (space delimited)"/>
        <attribute name="digest" default="sha1" description="Hash function to use"/>
        <attribute name="output" default="" description="Output generated manifest to file"/>

        <!-- Generate server RPM unique build id -->
        <sequential>
            <exec outputproperty="@{property}.checksum" executable="/bin/sh"
                logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    rm -f .checksum ;
                    for FILE in `find @{dirs} -name '*' -type f | sort -df` ;
                    do sed ${sed.extended.flag} 's|\$Id.*\$||g' &quot;${FILE}&quot;
                    | openssl @{digest} -r | awk '{ print $1 }' &gt;&gt; .checksum ;
                    done ;
                    for FILE in @{files} ;
                    do sed ${sed.extended.flag} 's|\$Id.*\$||g' &quot;${FILE}&quot;
                    | openssl @{digest} -r | awk '{ print $1 }' &gt;&gt; .checksum ;
                    done ;
                    openssl @{digest} -r .checksum | awk '{ print $1 }' ;
                    [ -z '@{output}' ] || mv .checksum @{output} ;
                    rm -f .checksum ;
                "/>
            </exec>
            <antcontrib:propertyregex property="@{property}" input="${@{property}.checksum}"
              regexp="^([a-z0-9]+)" select="\1" override="true"/>
            <fail message="Failed calculate checksum @{property}" unless="@{property}"/>
            <echo message="${@{property}}"/>
        </sequential>
    </macrodef>

    <!--
        MySQL Password Encryption

        Requirements:

            - You must have a local MySQL instance running

    -->
    <macrodef uri="urn:org.dellroad.ant" name="mysqlpass">
        <attribute name="password" description="String to be encrypted"/>
        <attribute name="algorithm" description="Encryption algorithm"/>
        <attribute name="classpathref" description="Classpath reference containing MySQL driver"/>
        <attribute name="mysqluser" default="" description="MySQL username"/>
        <attribute name="mysqlpass" default="" description="MySQL password"/>
        <sequential>

            <!-- Determine algorithm -->
            <antcontrib:if>
                <equals arg1="@{algorithm}" arg2="MD5"/>
                    <antcontrib:then>
                        <property name="algorithm.function" value="MD5"/>
                    </antcontrib:then>
                <antcontrib:elseif>
                    <equals arg1="@{algorithm}" arg2="SH1"/>
                    <antcontrib:then>
                        <property name="algorithm.function" value="SH1"/>
                    </antcontrib:then>
                </antcontrib:elseif>
                <antcontrib:elseif>
                    <equals arg1="@{algorithm}" arg2="SH2"/>
                    <antcontrib:then>
                        <property name="algorithm.function" value="SH2"/>
                    </antcontrib:then>
                </antcontrib:elseif>
                <antcontrib:else>
                    <antcontrib:then>
                        <fail message="ERROR: @{algorithm} is not a supported algorithm" unless="algorithm.function"/>
                    </antcontrib:then>
                </antcontrib:else>
            </antcontrib:if>

            <echo message="Password `@{password}' encrypted with `${algorithm.function}'"/>

            <!-- Encrypt password -->
            <sql driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/" classpathref="@{classpathref}"
              userid="@{mysqluser}" password="@{mysqlpass}" print="true" showheaders="false" showtrailers="false">
                <transaction>
                    SELECT ${algorithm.function}('@{password}');
                </transaction>
            </sql>
        </sequential>
    </macrodef>

    <!--
        Schema Update Verification

        Requirements:

            - You must have a local MySQL instance running
            - You must have run the "setupSchemacheck.sql" script on it

        How this works:

          - The local MySQL database as a user "schemacheck" (same p/w) with all priviledges on schemacheck\_%
          - LiquiBase *should* automatically detect any schema differences and if so the build will fail
          - In any case, the SQL exports are diff'd as well; some differences might not be material but do a double check
    -->
    <macrodef uri="urn:org.dellroad.ant" name="schemacheck">
        <attribute name="original" description="Starting schema file"/>
        <attribute name="changes" description="Update schema file"/>
        <attribute name="expected" description="Expected result schema file"/>
        <attribute name="classpathref" description="Classpath reference containing MySQL driver and Liquibase &gt; 2.0.0"/>
        <sequential>

            <!-- Reset -->
            <delete dir="build/schemacheck"/>
            <mkdir dir="build/schemacheck"/>

            <!-- Create check databases -->
            <sql driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/" classpathref="@{classpathref}"
              userid="schemacheck" password="schemacheck" print="false" showheaders="false" showtrailers="false">
                <transaction>
                    DROP DATABASE IF EXISTS `schemacheck_1`;
                    DROP DATABASE IF EXISTS `schemacheck_2`;
                    CREATE DATABASE `schemacheck_1` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;
                    CREATE DATABASE `schemacheck_2` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;
                </transaction>
            </sql>

            <!-- Apply original schema plus all updates to database #1 -->
            <sql driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/schemacheck_1?autoGenerateTestcaseScript=true"
              classpathref="@{classpathref}" userid="schemacheck" password="schemacheck" print="false" showheaders="false"
              showtrailers="false" autocommit="true">
                <transaction src="@{original}"/>
                <transaction src="@{changes}"/>
            </sql>

            <!-- Apply up-to-date schema to database #2 -->
            <sql driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/schemacheck_2" classpathref="@{classpathref}"
              userid="schemacheck" password="schemacheck" print="false" showheaders="false" showtrailers="false">
                <transaction src="@{expected}"/>
            </sql>

            <!-- Dump schemas as flat files -->
            <exec executable="mysqldump" output="build/schemacheck/1.sql" logError="true" failonerror="true">
                <arg line="-u schemacheck --password=schemacheck --host=localhost --no-data schemacheck_1"/>
            </exec>
            <exec executable="mysqldump" output="build/schemacheck/2.sql" logError="true" failonerror="true">
                <arg line="-u schemacheck --password=schemacheck --host=localhost --no-data schemacheck_2"/>
            </exec>

            <!-- Compute schema diff using liquibase -->
            <taskdef resource="liquibasetasks.properties" classpathref="@{classpathref}"/>
            <diffDatabase driver="com.mysql.jdbc.Driver" classpathref="@{classpathref}"
              url="jdbc:mysql://localhost/schemacheck_1" username="schemacheck" password="schemacheck"
              referenceUrl="jdbc:mysql://localhost/schemacheck_2" referenceUsername="schemacheck" referencePassword="schemacheck"
              outputFile="build/schemacheck/diff.txt">
            </diffDatabase>
            <exec executable="sh" logError="true" failonerror="false">
                <arg value="-c"/>
                <arg value="
                    cat build/schemacheck/diff.txt
                       | grep -vE '^(Reference|Target) Database: '
                       | grep -vE ': (EQUAL|NONE)$$'
                       &gt; build/schemacheck/mismatch.txt;
                    true;
                "/>
            </exec>

            <!-- Drop databases -->
            <sql driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost/" classpathref="@{classpathref}"
              userid="schemacheck" password="schemacheck" print="false" showheaders="false" showtrailers="false">
                DROP DATABASE `schemacheck_1`;
                DROP DATABASE `schemacheck_2`;
            </sql>

            <!-- Show liquibase schema differences -->
            <concat>
                <fileset file="build/schemacheck/mismatch.txt"/>
            </concat>
            <condition property="schemacheck.match">
                <filesmatch file1="build/schemacheck/mismatch.txt" file2="/dev/null"/>
            </condition>
            <fail message="ERROR: schema mismatch (see above for details)" unless="schemacheck.match"/>

            <!-- Show diff(1) of schema dumps -->
            <exec executable="diff" logError="true" failonerror="false">
                <arg value="-u"/>
                <arg value="-I"/>
                <arg value="^-- Host: localhost"/>
                <arg value="-I"/>
                <arg value="^-- Dump completed on"/>
                <arg value="build/schemacheck/1.sql"/>
                <arg value="build/schemacheck/2.sql"/>
            </exec>
        </sequential>
    </macrodef>

    <macrodef uri="urn:org.dellroad.ant" name="verifyclean">
        <sequential>
            <exec outputproperty="verifyclean.svn.version" executable="/bin/sh" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="svnversion"/>
            </exec>
            <fail message="!&#10;&#10;
                *** ERROR ***&#10;&#10;
                The checked out code is not clean (SVN revision is `${verifyclean.svn.version}').&#10;&#10;
                Please SVN update and/or commit first (or invoke ant with -Dpublish.dirty=true&#10;
                if you really know what you're doing).&#10;">
                <condition>
                    <not>
                        <or>
                            <isset property="publish.dirty"/>
                            <matches pattern="^[0-9.]+$" string="${verifyclean.svn.version}"/>
                        </or>
                    </not>
                </condition>
            </fail>
        </sequential>
    </macrodef>

    <!-- RPM build -->
    <macrodef uri="urn:org.dellroad.ant" name="rpmbuild">
        <attribute name="specfile" default="${ant.project.name}.spec" description="Name of RPM spec file"/>
        <attribute name="buildflag" default="-bb" description="rpmbuild(1) build flag"/>
        <attribute name="rpmflags" default="" description="Additional flags to rpmbuild"/>
        <attribute name="fresh" default="true" description="Blow away old RPMs in dist/RPMS first"/>
        <element name="source-preparation" optional="yes"/>
        <sequential>
            <delete dir="build/rpm"/>
            <mkdir dir="build/rpm/BUILD"/>
            <mkdir dir="build/rpm/RPMS"/>
            <mkdir dir="build/rpm/SOURCES"/>
            <mkdir dir="build/rpm/SPECS"/>
            <mkdir dir="build/rpm/SRPMS"/>
            <antcontrib:if>
                <istrue value="@{fresh}"/>
                <antcontrib:then>
                    <delete dir="dist/RPMS"/>
                </antcontrib:then>
            </antcontrib:if>
            <mkdir dir="dist/RPMS"/>
            <dellroad:svnrevision property="svn_revision"/>
            <antcontrib:if>
                <available file="src/rpm/@{specfile}" type="file"/>
                <antcontrib:then>
                    <copy file="src/rpm/@{specfile}" todir="build/rpm/SPECS" verbose="true"/>
                </antcontrib:then>
            </antcontrib:if>
            <antcontrib:if>
                <available file="src/sources" type="dir"/>
                <antcontrib:then>
                    <copy todir="build/rpm/SOURCES" verbose="true">
                        <fileset dir="src/sources">
                            <include name="**/*"/>
                            <exclude name="**/.svn"/>
                        </fileset>
                    </copy>
                </antcontrib:then>
            </antcontrib:if>
            <source-preparation/>
            <!-- workaround for bug in ant 1.7.0 Rpm.java, line 123 (missing space) -->
            <property name="mytopdir" value="${basedir}/build/rpm"/>
            <rpm topdir="build/rpm" specfile="@{specfile}" command="@{buildflag} --define '_topdir ${mytopdir}'
              --define 'svn_revision ${svn_revision}' @{rpmflags}"
              failOnError="true"/>
            <copy todir="dist" overwrite="true" verbose="true">
                <fileset dir="build/rpm">
                    <include name="RPMS/*/*.rpm"/>
                </fileset>
            </copy>
        </sequential>
    </macrodef>

    <!-- KIWI build -->
    <macrodef uri="urn:org.dellroad.ant" name="kiwibuild">
        <attribute name="dirs" default="src/kiwi" description="Directories containing KIWI appliance source files"/>
        <attribute name="kiwidir" default="${basedir}/build/kiwi" description="Directory in which to copy files and run the build"/>
        <attribute name="distdir" default="${basedir}/dist/KIWI" description="Directory in which to place built KIWI images"/>
        <attribute name="format" default="tar.gz" description="Format of KIWI appliance source archive"/>
        <attribute name="archivedir" default="src/archives" description="Directory containing KIWI appliance source archive"/>
        <attribute name="archive" default="" description="Use archived KIWI appliance source (must be @{format})"/>
        <attribute name="buildnumfile" default="${user.home}/.kiwibuild_numbers" description="Build number cache file"/>
        <attribute name="fresh" default="true" description="Blow away old KIWI images in dist/KIWI first"/>
        <attribute name="kiwiflags" default="" description="Additional flags to kiwi"/>
        <attribute name="checksum" default="false" description="Whether to respect checksum of archive"/>
        <attribute name="suwrapper" default="/usr/bin/sudo" description="Wrapper for su"/>
        <sequential>

            <!-- Get SVN revision -->
            <dellroad:svnrevision property="kiwibuild.svn.revision"/>

            <!-- Set create appliance script -->
            <property name="create.appliance" value="./create_appliance.sh"/>

            <!-- Get build number -->
            <exec executable="/bin/bash" outputproperty="kiwibuild.build.number" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    [ -f @{buildnumfile} ] || touch @{buildnumfile};
                    BNUM=`awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { print $$2 }' @{buildnumfile} 2&gt;/dev/null`;
                    if [ -z $${BNUM} ]; then
                        echo &quot;$${PROJKEY}=1&quot; &gt;&gt; @{buildnumfile};
                        BNUM=1;
                    fi;
                    echo $${BNUM};
                "/>
            </exec>

            <!-- Blow away previously built KIWI images (if any) -->
            <antcontrib:if>
                <istrue value="@{fresh}"/>
                <antcontrib:then>
                    <delete dir="@{distdir}"/>
                </antcontrib:then>
            </antcontrib:if>
            <mkdir dir="@{distdir}"/>

            <!-- Setup KIWI directory -->
            <delete dir="@{kiwidir}"/>
            <mkdir dir="@{kiwidir}"/>

            <!-- Explode archive if applicable -->
            <antcontrib:if>
                <equals arg1="@{archive}" arg2=""/>
                <antcontrib:then>
                    <!-- no archive, no action -->
                    <property name="kiwidir" value="@{kiwidir}"/>
                    <property name="imagedir" value="@{kiwidir}/image"/>
                </antcontrib:then>
                <antcontrib:else>
                    <antcontrib:if>
                        <available file="@{archivedir}/@{archive}.@{format}"/>
                        <antcontrib:then>
                            <gunzip src="@{archivedir}/@{archive}.@{format}"/>
                            <untar src="@{archivedir}/@{archive}.tar" dest="@{kiwidir}"/>
                            <delete file="@{archivedir}/@{archive}.tar"/>
                            <exec executable="/bin/bash" logError="true" failonerror="true">
                                <arg value="-c"/>
                                <arg value="
                                  [ &quot;@{checksum}&quot; != &quot;false&quot; ]
                                  || find @{kiwidir}/@{archive} -name '.checksum.md5' | xargs rm -rf;
                                "/>
                            </exec>
                            <property name="kiwidir" value="@{kiwidir}/@{archive}"/>
                            <property name="imagedir" value="@{kiwidir}/@{archive}/image"/>
                        </antcontrib:then>
                        <antcontrib:else>
                            <fail message="ERROR: @{archive} not found"/>
                        </antcontrib:else>
                    </antcontrib:if>
                </antcontrib:else>
            </antcontrib:if>

            <!-- Set up KIWI directory by copying files from @{dirs} (overwriting existing files) -->
            <antcontrib:for list="@{dirs}" param="dir" trim="true">
                <sequential>
                    <antcontrib:if>
                        <available file="${kiwidir}/@{dir}" type="dir"/>
                        <antcontrib:then>
                            <copy todir="${kiwidir}/@{dir}/" overwrite="true">
                                <fileset dir="@{dir}" includes="**/*"/>
                            </copy>
                        </antcontrib:then>
                        <antcontrib:else>
                            <copy todir="${kiwidir}/" overwrite="true">
                                <fileset dir="@{dir}" includes="**/*"/>
                            </copy>
                        </antcontrib:else>
                    </antcontrib:if>
                </sequential>
            </antcontrib:for>

            <!-- Prep files -->
            <replace
              dir="${kiwidir}">
                <replacefilter token="@kiwibuild_svn_revision@" value="${kiwibuild.svn.revision}"/>
                <replacefilter token="@kiwibuild_build_number@" value="${kiwibuild.build.number}"/>
                <replacefilter token="@kiwibuild_author@" value="${user}"/>
            </replace>

            <!-- Build KIWI image(s) -->
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set +e;
                    cd ${kiwidir};
                    chmod +x ${create.appliance};
                    @{suwrapper} ${create.appliance} @{kiwiflags};
                    [ &quot;$?&quot; != &quot;0&quot; ] &amp;&amp; echo ERROR: $? &amp;&amp; exit 1;
                    cd -;
                    cp -rf ${imagedir} @{distdir}/;
                "/>
            </exec>

            <!-- Increment build number for next time -->
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { printf &quot;%s=%s\n&quot;, $$1, $$2 + 1 }'
                      &lt; @{buildnumfile} &gt; @{buildnumfile}.new;
                    mv @{buildnumfile}.new @{buildnumfile};
                "/>
            </exec>

        </sequential>
    </macrodef>

    <!-- OBS clone -->
    <macrodef uri="urn:org.dellroad.ant" name="obsclone">
        <attribute name="dirs" default="src/sources,src/rpm" description="Directories containing OBS files (spec, patches, etc.)"/>
        <attribute name="obsdir" default="${basedir}/build/obs" description="Directory in which to copy files and run the build"/>
        <attribute name="distdir" default="${basedir}/dist/RPMS" description="Directory in which to place built RPMs"/>
        <attribute name="project" default="openSUSE:11.3" description="openSUSE project to build against"/>
        <attribute name="package" default="" description="openSUSE project package (if applicable)"/>
        <attribute name="repository" default="standard" description="openSUSE project repository to build against"/>
        <attribute name="buildroot" default="${user.home}/.obsbuild_root" description="OBS build root"/>
        <attribute name="pkgcachedir" default="" description="OBS package cache directory"/>
        <attribute name="buildnumfile" default="${user.home}/.obsclone_numbers" description="Build number cache file"/>
        <attribute name="fresh" default="true" description="Blow away old RPMs in dist/RPMS first"/>
        <attribute name="revision" default="latest" description="Revision of OBS project/package"/>
        <attribute name="oscflags" default="" description="Additional flags to osc"/>
        <attribute name="oscbuildflags" default="" description="Additional flags to osc build"/>
        <attribute name="osccoflags" default="" description="Additional flags to osc checkout"/>
        <attribute name="link" default="false" description="Treat this project as a linked OBS project"/>
        <attribute name="aggregate" default="false" description="Treat this project as an aggregated OBS project"/>
        <sequential>

            <!-- Blow away previously built RPMs (if any) -->
            <antcontrib:if>
                <istrue value="@{fresh}"/>
                <antcontrib:then>
                    <delete dir="@{distdir}"/>
                </antcontrib:then>
            </antcontrib:if>
            <mkdir dir="@{distdir}"/>

            <!-- Get SVN revision -->
            <dellroad:svnrevision property="obsclone.svn.revision"/>

            <!-- Get build number -->
            <exec executable="/bin/bash" outputproperty="obsclone.build.number" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    [ -f @{buildnumfile} ] || touch @{buildnumfile};
                    BNUM=`awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { print $$2 }' @{buildnumfile} 2&gt;/dev/null`;
                    if [ -z $${BNUM} ]; then
                        echo &quot;$${PROJKEY}=1&quot; &gt;&gt; @{buildnumfile};
                        BNUM=1;
                    fi;
                    echo $${BNUM};
                "/>
            </exec>

            <!-- Setup OBS directory -->
            <delete dir="@{obsdir}"/>
            <mkdir dir="@{obsdir}"/>

            <!-- Do the checkout -->
            <exec executable="/usr/bin/python" failonerror="true" logError="true" dir="@{obsdir}">
                <arg value="-u"/>
                <arg value="/usr/bin/osc"/>
                <arg line="@{oscflags}"/>
                <arg value="checkout"/>
                <arg line="@{osccoflags}"/>
                <arg value="--unexpand-link"/>
                <arg value="@{project}"/>
                <arg value="@{package}"/>
                <arg value="--revision=@{revision}"/>
                <env key="OSC_PACKAGECACHEDIR" value="@{pkgcachedir}"/>
                <env key="OSC_SU_WRAPPER" value="/usr/bin/sudo"/>
            </exec>

            <!-- Determine OBS checkout directory -->
            <antcontrib:if>
                <equals arg1="@{package}" arg2=""/>
                <antcontrib:then>
                    <property name="obsdir" value="@{obsdir}/@{project}"/>
                </antcontrib:then>
                <antcontrib:else>
                    <property name="obsdir" value="@{obsdir}/@{project}/@{package}"/>
                </antcontrib:else>
            </antcontrib:if>

            <!-- Set up OBS directory by copying files from @{dirs} -->
            <antcontrib:for list="@{dirs}" param="dir" trim="true">
                <sequential>
                    <copy todir="@{obsdir}">
                        <fileset dir="@{dir}" includes="**/*"/>
                    </copy>
                </sequential>
            </antcontrib:for>

            <!-- Prep linked or aggregated OBS project -->
            <antcontrib:if>
                <or>
                    <istrue value="@{link}"/>
                    <istrue value="@{aggregate}"/>
                </or>
                <antcontrib:then>
                    <copy todir="${obsdir}">
                        <fileset dir="@{obsdir}">
                            <and>
                                <depth max="1"/>
                                <type type="file"/>
                            </and>
                        </fileset>
                    </copy>
                </antcontrib:then>
            </antcontrib:if>

            <!-- Set up overlay files -->
            <mkdir dir="@{obsdir}/overlay"/>
            <copy todir="@{obsdir}/overlay">
                <fileset dir="/" includes="etc/resolv.conf"/>
            </copy>

            <!-- Do the build -->
            <exec executable="/usr/bin/python" failonerror="true" logError="true" dir="${obsdir}">
                <arg value="-u"/>
                <arg value="/usr/bin/osc"/>
                <arg line="@{oscflags}"/>
                <arg value="build"/>
                <arg line="@{oscbuildflags}"/>
                <arg value="--root=@{buildroot}"/>
                <arg value="--release=${obsclone.svn.revision}.${obsclone.build.number}"/>
                <arg value="--keep-pkgs=@{distdir}"/>
                <arg value="--rsync-src=@{obsdir}/overlay"/>
                <arg value="--rsync-dest=/"/>
                <arg value="@{repository}"/>
                <env key="OSC_PACKAGECACHEDIR" value="@{pkgcachedir}"/>
                <env key="OSC_SU_WRAPPER" value="/usr/bin/sudo"/>
            </exec>

            <!-- Increment build number for next time -->
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { printf &quot;%s=%s\n&quot;, $$1, $$2 + 1 }'
                      &lt; @{buildnumfile} &gt; @{buildnumfile}.new;
                    mv @{buildnumfile}.new @{buildnumfile};
                "/>
            </exec>
        </sequential>
    </macrodef>

    <!-- OBS build -->
    <macrodef uri="urn:org.dellroad.ant" name="obsbuild">
        <attribute name="dirs" default="src/sources,src/rpm" description="Directories containing OBS files (spec, patches, etc.)"/>
        <attribute name="obsdir" default="${basedir}/build/obs" description="Directory in which to copy files and run the build"/>
        <attribute name="distdir" default="${basedir}/dist/RPMS" description="Directory in which to place built RPMs"/>
        <attribute name="project" default="openSUSE:11.3" description="openSUSE project to build against"/>
        <attribute name="package" default="" description="openSUSE project package (if applicable)"/>
        <attribute name="repository" default="standard" description="openSUSE project repository to build against"/>
        <attribute name="buildroot" default="${user.home}/.obsbuild_root" description="OBS build root"/>
        <attribute name="pkgcachedir" default="" description="OBS package cache directory"/>
        <attribute name="buildnumfile" default="${user.home}/.obsbuild_numbers" description="Build number cache file"/>
        <attribute name="fresh" default="true" description="Blow away old RPMs in dist/RPMS first"/>
        <attribute name="oscflags" default="" description="Additional flags to osc"/>
        <attribute name="oscbuildflags" default="" description="Additional flags to osc build"/>
        <sequential>

            <!-- Blow away previously built RPMs (if any) -->
            <antcontrib:if>
                <istrue value="@{fresh}"/>
                <antcontrib:then>
                    <delete dir="@{distdir}"/>
                </antcontrib:then>
            </antcontrib:if>
            <mkdir dir="@{distdir}"/>

            <!-- Get SVN revision -->
            <dellroad:svnrevision property="obsbuild.svn.revision"/>

            <!-- Get build number -->
            <exec executable="/bin/bash" outputproperty="obsbuild.build.number" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    [ -f @{buildnumfile} ] || touch @{buildnumfile};
                    BNUM=`awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { print $$2 }' @{buildnumfile} 2&gt;/dev/null`;
                    if [ -z $${BNUM} ]; then
                        echo &quot;$${PROJKEY}=1&quot; &gt;&gt; @{buildnumfile};
                        BNUM=1;
                    fi;
                    echo $${BNUM};
                "/>
            </exec>

            <!-- Set up OBS directory by copying files from @{dirs} -->
            <delete dir="@{obsdir}"/>
            <mkdir dir="@{obsdir}"/>
            <antcontrib:for list="@{dirs}" param="dir" trim="true">
                <sequential>
                    <copy todir="@{obsdir}">
                        <fileset dir="@{dir}" includes="**/*"/>
                    </copy>
                </sequential>
            </antcontrib:for>

            <!-- Set up overlay files -->
            <mkdir dir="@{obsdir}/overlay"/>
            <copy todir="@{obsdir}/overlay">
                <fileset dir="/" includes="etc/resolv.conf"/>
            </copy>

            <!-- Do the build -->
            <exec executable="/usr/bin/python" failonerror="true" logError="true" dir="@{obsdir}">
                <arg value="-u"/>
                <arg value="/usr/bin/osc"/>
                <arg line="@{oscflags}"/>
                <arg value="build"/>
                <arg line="@{oscbuildflags}"/>
                <arg value="--root=@{buildroot}"/>
                <arg value="--local-package"/>
                <arg value="--alternative-project=@{project}"/>
                <arg value="--release=${obsbuild.svn.revision}.${obsbuild.build.number}"/>
                <arg value="--keep-pkgs=@{distdir}"/>
                <arg value="--rsync-src=@{obsdir}/overlay"/>
                <arg value="--rsync-dest=/"/>
                <arg value="@{repository}"/>
                <env key="OSC_PACKAGECACHEDIR" value="@{pkgcachedir}"/>
                <env key="OSC_SU_WRAPPER" value="/usr/bin/sudo"/>
            </exec>

            <!-- Increment build number for next time -->
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    PROJKEY=`svn info .
                      | awk '
                        /^Repository UUID:/ { UUID=$$3; }
                        /^URL:/             { URL=$$2 }
                        /^Repository Root:/ { ROOT=$$3; }
                        END { printf &quot;%s:%s\n&quot;, UUID, substr(URL, length(ROOT) + 1) }'
                      | sed ${sed.extended.flag} 's|/|_|g'`;
                    awk -F= '/^'&quot;$${PROJKEY}&quot;'=/ { printf &quot;%s=%s\n&quot;, $$1, $$2 + 1 }'
                      &lt; @{buildnumfile} &gt; @{buildnumfile}.new;
                    mv @{buildnumfile}.new @{buildnumfile};
                "/>
            </exec>
        </sequential>
    </macrodef>

    <!-- RPM publish -->
    <macrodef uri="urn:org.dellroad.ant" name="rpmdist">
        <attribute name="repodir" default="/opt/repo/devel" description="Base RPM repository directory"/>
        <attribute name="susever" default="" description="Repository openSuSE version (default current)"/>
        <attribute name="purge" default="false" description="Whether to remove all other revisions from repository"/>
        <sequential>

            <!-- Refuse to publish uncommitted code -->
            <dellroad:verifyclean/>

            <!-- Check umask -->
            <dellroad:checkumask u="rwx" g="rwx" o="rx"/>

            <!-- Get SuSE version -->
            <antcontrib:if>
                <equals arg1="@{susever}" arg2=""/>
                <antcontrib:then>
                    <dellroad:suseversion property="_rpmdist.@{susever}"/>
                </antcontrib:then>
                <antcontrib:else>
                    <property name="_rpmdist.@{susever}" value="@{susever}"/>
                </antcontrib:else>
            </antcontrib:if>

            <!-- Optionally remove older versions -->
            <antcontrib:if>
                <equals arg1="@{purge}" arg2="true"/>
                <antcontrib:then>
                    <echo message="Note: removing all other versions of these RPM(s) from the repository"/>
                    <exec executable="/bin/bash" logError="true" failonerror="true">
                        <arg value="-c"/>
                        <arg value="
                            set -e;
                            find dist/RPMS -type f -name \*.rpm -print | while read FILE; do
                                NAME=`rpm -qp --queryformat='%{name}\n' &quot;$${FILE}&quot;`;
                                find @{repodir}/${_rpmdist.@{susever}} -type f -name &quot;$${NAME}-*.rpm&quot; -print0
                                  | xargs -n 1 -0 -I@ sh -c 'test `rpm -qp --queryformat=&quot;%{name}&quot; &quot;@&quot;`
                                    = &quot;'&quot;$${NAME}&quot;'&quot; &amp;&amp; echo &quot;@&quot;'
                                  | xargs -n 1 -r -I@ sh -c 'echo Removing @; rm @';
                            done;
                        "/>
                    </exec>
                </antcontrib:then>
            </antcontrib:if>

            <!-- Copy new RPMs into the repository, but avoid mixing openSUSE versions -->
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    echo 'Publishing RPMs to @{repodir}/${_rpmdist.@{susever}}:';
                    cd dist/RPMS;
                    (
                        find * -type f -name '*.rpm' -print | grep -vE '^.*\.suse[0-9.]+\..*$';
                        find * -type f -name '*.rpm' -print | grep -E '^.*\.suse@{susever}\..*$';
                    ) | cpio --quiet -pmudv '@{repodir}/${_rpmdist.@{susever}}' 2&gt;&amp;1
                      | sed ${sed.extended.flag} 's|@{repodir}/${_rpmdist.@{susever}}/[^/]+/|    |g'
                      | sort;
                "/>
            </exec>

            <!-- Regenerate repository meta-data -->
            <exec executable="createrepo" logError="true" failonerror="true">
                <arg value="-q"/>
                <arg value="-c"/>
                <arg value="@{repodir}/${_rpmdist.@{susever}}/cache"/>
                <arg value="--update"/>
                <arg value="@{repodir}/${_rpmdist.@{susever}}"/>
            </exec>

            <!-- Work around this bug: https://bugzilla.novell.com/show_bug.cgi?id=659915 -->
            <exec executable="chmod" logError="true" failonerror="true">
                <arg value="g+w"/>
                <arg value="@{repodir}/${_rpmdist.@{susever}}/repodata"/>
            </exec>
        </sequential>
    </macrodef>

    <!-- Ivy module publish -->
    <macrodef uri="urn:org.dellroad.ant" name="ivydist">
        <attribute name="version" description="Ivy module version"/>
        <attribute name="resolver" default="local" description="Name of ivy resolver with which to publish"/>
        <attribute name="settingsRef" default="build-macros-ivy-settings" description="Reference to ivy settings"/>
        <attribute name="ivyfile" default="${basedir}/src/ivy/ivy.xml" description="Ivy file to publish"/>
        <element name="module-preparation"/>
        <sequential>

            <!-- Refuse to publish uncommitted code -->
            <dellroad:verifyclean/>

            <!-- Check umask -->
            <dellroad:checkumask u="rwx" g="rwx" o="rx"/>

            <!-- Copy ivy.xml -->
            <delete dir="${basedir}/build/ivy"/>
            <mkdir dir="${basedir}/build/ivy"/>
            <copy file="@{ivyfile}" toFile="${basedir}/build/ivy/ivy.xml"/>
            <module-preparation/>

            <!-- Publish module -->
            <ivy:resolve settingsRef="@{settingsRef}" file="${basedir}/build/ivy/ivy.xml" log="download-only"/>
            <ivy:publish settingsRef="build-macros-ivy-settings" forcedeliver="true" validate="true"
              overwrite="true" resolver="@{resolver}" srcivypattern="${basedir}/build/ivy/ivy.xml"
              pubrevision="@{version}">
                <artifacts pattern="${basedir}/build/ivy/[type]s/[artifact].[ext]"/>
            </ivy:publish>
        </sequential>
    </macrodef>

    <!--
        Unit test macro

        Requires:
            path "javac.classpath"
            path "unittest.classpath"
            path "testng.classpath"
            path "cobertura.classpath"
    -->
    <macrodef uri="urn:org.dellroad.ant" name="unit-tests">
        <attribute name="testngfile" default="${basedir}/src/test/testng.xml" description="TestNG control file"/>
        <element name="excludes" optional="yes"/>
        <element name="addclasspath" optional="yes"/>
        <element name="testng" optional="yes"/>
        <sequential>

            <!-- Define TestNG and Cobertura ant tasks -->
            <taskdef uri="urn:org.testng"
              resource="testngtasks" classpathref="testng.classpath"/>
            <taskdef uri="urn:net.sf.cobertura"
              resource="tasks.properties" classpathref="cobertura.classpath"/>

            <!-- Instrument Classes -->
            <delete dir="${basedir}/build/cobertura"/>
            <delete dir="${basedir}/build/reports/coverage"/>
            <mkdir dir="${basedir}/build/cobertura/classes"/>
            <mkdir dir="${basedir}/build/reports/coverage"/>
            <cobertura:cobertura-instrument todir="${basedir}/build/cobertura/classes"
              datafile="${basedir}/build/cobertura/cobertura.ser">
                <fileset dir="${basedir}/build/classes">
                    <include name="**/*.class"/>
                    <excludes/>
                </fileset>
            </cobertura:cobertura-instrument>

            <!-- Run tests -->
            <testng:testng outputDir="${basedir}/build/reports/tests" haltOnfailure="true">
                <xmlfileset file="@{testngfile}"/>
                <jvmarg value="-Djava.awt.headless=true"/>
                <sysproperty key="net.sourceforge.cobertura.datafile" file="${basedir}/build/cobertura/cobertura.ser"/>
                <classpath>
                    <addclasspath/>
                    <pathelement location="${basedir}/build/cobertura/classes"/>
                    <pathelement location="${basedir}/build/classes"/>
                    <pathelement location="${basedir}/build/test"/>
                    <pathelement location="${basedir}/build/resources"/>
                    <path refid="javac.classpath"/>
                    <path refid="unittest.classpath"/>
                    <path refid="cobertura.classpath"/>
                </classpath>
                <testng/>
            </testng:testng>

            <!-- Generate coverage report -->
            <cobertura:cobertura-report format="html" destdir="${basedir}/build/reports/coverage"
              srcdir="${basedir}/src/java" datafile="${basedir}/build/cobertura/cobertura.ser"/>
        </sequential>
    </macrodef>

    <presetdef uri="urn:org.dellroad.ant" name="javac-default">
        <javac includeantruntime="no"
               compiler="modern"
               deprecation="true"
               source="1.6"
               target="1.6"
               debug="true">
            <compilerarg line="${javac.compiler.flags}"/>
        </javac>
    </presetdef>

    <!--
        Javadoc macro

        Requires:
            path "javac.classpath"
        Optional:
            property "javac.compiler.flags"
    -->
    <macrodef uri="urn:org.dellroad.ant" name="javadoc">
        <attribute name="title" default="Java Class Library API"/>
        <element name="links" optional="yes"/>
        <element name="excludes" optional="yes"/>
        <element name="addclasspath" optional="yes"/>
        <sequential>
            <antcontrib:outofdate>
                <sourcefiles>
                    <fileset dir="src/java">
                        <include name="**/*.java"/>
                        <excludes/>
                    </fileset>
                </sourcefiles>
                <targetfiles path="build/reports/javadoc/index.html"/>
                <sequential>
                    <delete dir="build/reports/javadoc"/>
                    <mkdir dir="build/reports/javadoc"/>
                    <javadoc destdir="build/reports/javadoc" use="true"
                      source="1.5" breakiterator="yes" linksource="true"
                      windowtitle="@{title}" doctitle="@{title}" failonerror="true">
                        <classpath>
                            <addclasspath/>
                            <path refid="javac.classpath"/>
                        </classpath>
                        <packageset dir="src/java" defaultexcludes="yes">
                            <include name="**/*"/>
                            <excludes/>
                        </packageset>
                        <links/>
                    </javadoc>
                </sequential>
            </antcontrib:outofdate>
        </sequential>
    </macrodef>

    <!--
        Checkstyle macro

        Requires:
            path "javac.classpath"
            path "unittest.classpath"
            path "checkstyle.classpath"
    -->
    <macrodef uri="urn:org.dellroad.ant" name="checkstyle">
        <attribute name="config" default="${build.macros.dir}/checkstyle/checkstyle.xml"/>
        <attribute name="style" default="${build.macros.dir}/checkstyle/checkstyle-frames-errors.xsl"/>
        <attribute name="textstyle" default="${build.macros.dir}/checkstyle/checkstyle-text.xsl"/>
        <attribute name="dir" default="${basedir}/build/reports/checkstyle"/>
        <attribute name="title" default="DellRoad.ORG Checkstyle Report"/>
        <attribute name="maxErrors" default="0"/>
        <attribute name="maxWarnings" default="0"/>
        <attribute name="showWarnings" default="true"/>
        <element name="excludes" optional="yes"/>
        <sequential>
            <mkdir dir="@{dir}"/>

            <!-- (Re)run checkstyle if necessary -->
            <antcontrib:outofdate>
                <sourcefiles>
                    <fileset dir="src">
                        <include name="**/*.java"/>
                        <exclude name="**/*MBean.java"/>
                        <excludes/>
                    </fileset>
                </sourcefiles>
                <targetfiles path="${dir}/report.xml"/>
                <sequential>

                    <!-- Run checkstyle -->
                    <delete dir="@{dir}"/>
                    <mkdir dir="@{dir}"/>
                    <taskdef uri="urn:net.sf.checkstyle"
                      resource="checkstyletask.properties" classpathref="checkstyle.classpath"/>
                    <checkstyle:checkstyle failOnViolation="false" failureProperty="checkstyle.failed"
                      config="@{config}" maxErrors="@{maxErrors}" maxWarnings="@{maxWarnings}">
                        <property key="checkstyle.cache.file" file="@{dir}/cachefile"/>
                        <formatter type="xml" toFile="@{dir}/report.xml"/>
                        <fileset dir="${basedir}/src">
                            <include name="**/*.java"/>
                            <exclude name="**/*MBean.java"/>
                            <excludes/>
                        </fileset>
                        <classpath>
                            <pathelement location="${basedir}/build/classes"/>
                            <pathelement location="${basedir}/build/test"/>
                            <path refid="javac.classpath"/>
                            <path refid="unittest.classpath"/>
                        </classpath>
                    </checkstyle:checkstyle>

                    <!-- Style XML report -->
                <!--
                    <xslt in="@{dir}/report.xml" out="@{dir}/report.out" style="@{style}">
                        <param name="title" expression="@{title}"/>
                        <param name="filename.strip.prefix" expression="${basedir}/"/>
                    </xslt>
                -->

                    <!-- Output textual version of report -->
                    <antcontrib:if>
                        <isset property="checkstyle.failed"/>
                        <antcontrib:then>
                            <xslt style="@{textstyle}" in="@{dir}/report.xml" out="/dev/stdout">
                                <param name="failed" expression="true"/>
                                <param name="filename.strip.prefix" expression="${basedir}/"/>
                                <param name="show.warnings" expression="@{showWarnings}"/>
                            </xslt>
                            <fail message="checkstyle failed"/>
                        </antcontrib:then>
                        <antcontrib:else>
                            <xslt style="@{textstyle}" in="@{dir}/report.xml" out="/dev/stdout">
                                <param name="failed" expression="false"/>
                                <param name="filename.strip.prefix" expression="${basedir}/"/>
                                <param name="show.warnings" expression="@{showWarnings}"/>
                            </xslt>
                        </antcontrib:else>
                    </antcontrib:if>
                </sequential>
            </antcontrib:outofdate>
        </sequential>
    </macrodef>

    <!--
        FindBugs macro

        Requires:
            path "findbugs.classpath"
    -->
    <macrodef uri="urn:org.dellroad.ant" name="findbugs">
        <attribute name="dir" description="Output directory" default="${basedir}/build/reports/findbugs"/>
        <attribute name="location" description="Directory where FindBugs is installed"/>
        <attribute name="reportLevel" description="Reporting level: low, medium, high" default="low"/>
        <attribute name="style" description="Report style: plain, default, fancy, fancy-hist, summary" default="default"/>
        <attribute name="effortLevel" description="Effort level: min, default, max" default="default"/>
        <sequential>

            <!-- Verify FindBugs exists -->
            <available file="@{location}" type="dir" property="findbugs.home.exists"/>
            <fail unless="findbugs.home.exists" message="Directory @{location} does not exist"/>

            <!-- Run FindBugs -->
            <antcontrib:outofdate>
                <sourcefiles>
                    <fileset dir="src/java" includes="**/*.java"/>
                </sourcefiles>
                <targetfiles path="@{dir}/report.xml"/>
                <sequential>

                    <!-- Clear out old stuff -->
                    <delete dir="@{dir}"/>
                    <mkdir dir="@{dir}"/>

                    <!-- Define task -->
                    <taskdef uri="urn:edu.umd.cs.findbugs" name="findbugs"
                      classpath="@{location}/lib/findbugs.jar"
                      classname="edu.umd.cs.findbugs.anttask.FindBugsTask"/>

                    <!-- Generate XML report -->
                    <findbugs:findbugs home="@{location}" outputFile="@{dir}/report.xml"
                      output="xml:withMessages" reportLevel="@{reportLevel}" effort="@{effortLevel}">
                        <auxClasspath refid="findbugs.classpath"/>
                        <sourcePath path="${basedir}/src/java" />
                        <class location="${basedir}/build/classes" />
                    </findbugs:findbugs>
                </sequential>
            </antcontrib:outofdate>

            <!-- Style that into HTML report -->
            <antcontrib:outofdate>
                <sourcefiles>
                    <fileset dir="@{dir}" includes="report.xml"/>
                </sourcefiles>
                <targetfiles path="@{dir}/index.html"/>
                <sequential>
                    <xslt style="@{location}/src/xsl/@{style}.xsl" in="@{dir}/report.xml" out="@{dir}/index.html"/>
                </sequential>
            </antcontrib:outofdate>
        </sequential>
    </macrodef>

    <!--
        Show FindBugs macro
    -->
    <macrodef uri="urn:org.dellroad.ant" name="showbugs">
        <attribute name="dir" description="Output directory" default="${basedir}/build/reports/findbugs"/>
        <attribute name="location" description="Directory where FindBugs is installed"/>
        <sequential>
            <available file="@{dir}/report.xml" type="file" property="findbugs.report.exists"/>
            <fail unless="findbugs.report.exists" message="File @{dir}/report.xml does not exist"/>
            <exec executable="@{location}/bin/findbugs" logError="true" failonerror="true">
                <arg value="-loadbugs"/>
                <arg value="@{dir}/report.xml"/>
                <arg value="-home"/>
                <arg value="@{location}"/>
            </exec>
        </sequential>
    </macrodef>

    <!--
        Cleanblanks macro
    -->
    <macrodef uri="urn:org.dellroad.ant" name="cleanblanks">
        <attribute name="location" description="Directory where cleanblanks is installed" default="/usr/bin"/>
        <attribute name="check" description="Locations where to check for whitespace style violations" default="${basedir}/src ${basedir}/*.xml"/>
        <sequential>
            <exec executable="/bin/bash" logError="true" failonerror="true">
                <arg value="-c"/>
                <arg value="
                    set -e;
                    if ! [ -x @{location}/cleanblanks ]; then
                        echo 'ERROR: invalid locatons &#34;@{location}&#34;.';
                        exit 1;
                    fi;
                    for CHECK in @{check}; do
                    if ! [ -d ${CHECK} -o -f ${CHECK} ]; then
                            echo 'ERROR: check location &#34;${CHECK}&#34; does not exist.';
                            exit 1;
                        fi;
                    done;
                "/>
            </exec>
            <exec executable="@{location}/cleanblanks" logError="true" failonerror="true">
                <arg value="-t"/>
                <arg value="-c"/>
                <arg value="@{check}"/>
            </exec>
        </sequential>
    </macrodef>

<!--
        ************* PREDEFINED TARGETS ****************
-->

    <target name="clean" depends="clean-project">
        <delete dir="build"/>
        <delete dir="dist"/>
    </target>
    <target name="clean-project"/>

    <!-- Find TestNG -->
    <target name="testng.classpath" unless="testng.classpath.resolved">
        <dellroad:ivymodpath pathid="testng.classpath" rev="6.+" org="org.testng" mod="testng"/>
        <property name="testng.classpath.resolved" value="true"/>
    </target>

    <!-- Find Cobertura -->
    <target name="cobertura.classpath" unless="cobertura.classpath.resolved">
        <dellroad:ivymodpath pathid="cobertura.classpath" rev="[1.9.3,2.0[" org="net.sourceforge.cobertura" mod="cobertura"/>
        <property name="cobertura.classpath.resolved" value="true"/>
    </target>

    <!-- Find Checkstyle -->
    <target name="checkstyle.classpath" unless="checkstyle.classpath.resolved">
        <dellroad:ivymodpath pathid="checkstyle.classpath" rev="5.4" org="com.puppycrawl" mod="checkstyle"/>
        <property name="checkstyle.classpath.resolved" value="true"/>
    </target>

    <target name="jpamodelgen" depends="javac" unless="jpamodelgen.completed">
        <antcontrib:if>
            <available file="src/java" type="dir"/>
            <antcontrib:then>
                <mkdir dir="build/classes"/>
                <antcontrib:outofdate>
                    <sourcefiles>
                        <fileset dir="src/java">
                            <include name="**/*.java"/>
                            <exclude name="**/package-info.java"/>
                        </fileset>
                    </sourcefiles>
                    <mapper type="glob" dir="src/java" from="*.java" to="build/classes/*.class"/>
                    <sequential>
                        <mkdir dir="build/metamodel"/>
                        <mkdir dir="build/metamodel/META-INF"/>
                        <copy file="src/conf/persistence.xml" todir="build/metamodel/META-INF"/>
                        <dellroad:javac-default srcdir="src/java" destdir="build/metamodel">
                            <classpath>
                                <path refid="javac.classpath"/>
                                <pathelement location="build/metamodel"/>
                            </classpath>
                            <compilerarg line="-proc:only"/>
                        </dellroad:javac-default>
                        <dellroad:javac-default srcdir="build/metamodel" destdir="build/classes">
                            <classpath>
                                <path refid="javac.classpath"/>
                                <pathelement location="build/classes"/>
                            </classpath>
                            <compilerarg line="-proc:none"/>
                        </dellroad:javac-default>
                    </sequential>
                </antcontrib:outofdate>
            </antcontrib:then>
        </antcontrib:if>
        <property name="jpamodelgen.completed" value="true"/>
    </target>

    <target name="javac" depends="javac-project, javac.classpath, testng.classpath" unless="javac.completed">

        <!-- Main classes -->
        <antcontrib:if>
            <available file="src/java" type="dir"/>
            <antcontrib:then>
                <mkdir dir="build/classes"/>
                <antcontrib:outofdate>
                    <sourcefiles>
                        <fileset dir="src/java">
                            <include name="**/*.java"/>
                            <exclude name="**/package-info.java"/>
                        </fileset>
                    </sourcefiles>
                    <mapper type="glob" dir="src/java" from="*.java" to="build/classes/*.class"/>
                    <sequential>
                        <mkdir dir="build/classes"/>
                        <dellroad:javac-default srcdir="src/java" destdir="build/classes">
                            <classpath refid="javac.classpath"/>
                            <compilerarg line="-proc:none"/>
                        </dellroad:javac-default>
                    </sequential>
                </antcontrib:outofdate>
            </antcontrib:then>
        </antcontrib:if>

        <!-- Test classes -->
        <antcontrib:if>
            <available file="src/test" type="dir"/>
            <antcontrib:then>
                <antcontrib:outofdate>
                    <sourcefiles>
                        <fileset dir="src/test">
                            <include name="**/*.java"/>
                            <exclude name="**/package-info.java"/>
                        </fileset>
                    </sourcefiles>
                    <mapper type="glob" dir="src/test" from="*.java" to="build/test/*.class"/>
                    <sequential>
                        <mkdir dir="build/test"/>
                        <dellroad:javac-default srcdir="src/test" destdir="build/test">
                            <classpath path="build/classes"/>
                            <classpath refid="javac.classpath"/>
                            <classpath refid="testng.classpath"/>
                        </dellroad:javac-default>
                    </sequential>
                </antcontrib:outofdate>
            </antcontrib:then>
        </antcontrib:if>
        <property name="javac.completed" value="true"/>
    </target>
    <target name="javac-project"/>

    <target name="reports" depends="reports-project">
        <dellroad:svnrevision property="svn_revision"/>
        <dellroad:suseversion property="suse_version"/>
        <tstamp>
            <format property="current.time" pattern="EEEE dd MMM yyyy HH:mm:ss"/>
        </tstamp>
        <xslt style="${build.macros.dir}/reports-index.xsl"
          in="${build.macros.dir}/reports-index.xsl" out="build/reports/index.html">
            <param name="basedir" expression="${basedir}"/>
            <param name="ant.project.name" expression="${ant.project.name}"/>
            <param name="svn.revision" expression="${svn_revision}"/>
            <param name="suse.version" expression="${suse_version}"/>
            <param name="version" expression="${version}"/>
            <param name="timestamp" expression="${current.time}"/>
        </xslt>
        <antcontrib:if>
            <available file="src/java" type="dir"/>
            <antcontrib:then>
                <antcall target="javadoc" inheritRefs="true"/>
            </antcontrib:then>
        </antcontrib:if>
        <antcontrib:if>
            <available file="src/java" type="dir"/>
            <antcontrib:then>
                <antcall target="checkstyle" inheritRefs="true"/>
            </antcontrib:then>
        </antcontrib:if>
        <antcontrib:if>
            <available file="src/test" type="dir"/>
            <antcontrib:then>
                <antcall target="tests" inheritRefs="true"/>
            </antcontrib:then>
        </antcontrib:if>
<!--
        <antcontrib:if>
            <available file="src/java" type="dir"/>
            <antcontrib:then>
                <antcall target="findbugs" inheritRefs="true"/>
            </antcontrib:then>
        </antcontrib:if>
-->
    </target>
    <target name="reports-project"/>

    <target name="remove-unused-imports">
        <exec executable="/bin/bash" logError="true" failonerror="true">
            <arg value="-c"/>
            <arg value="
                if ! [ -f build/reports/checkstyle/report.xml ]; then
                    echo 'ERROR: you must run &#34;ant checks-checkstyle&#34; first!';
                    exit 1;
                fi;
                if [ -f build/reports/checkstyle/removeUnusedImports.sh ]; then
                    echo 'ERROR: only run &#34;ant remove-unused-imports&#34; once!';
                    exit 1;
                fi;
            "/>
        </exec>
        <xslt style="${build.macros.dir}/checkstyle/unused-imports.xsl"
          in="build/reports/checkstyle/report.xml" out="build/reports/checkstyle/removeUnusedImports.sh"/>
        <exec executable="/bin/bash" logError="true" failonerror="true">
            <arg value="-x"/>
            <arg value="build/reports/checkstyle/removeUnusedImports.sh"/>
        </exec>
    </target>

    <target name="diag">
        <diagnostics/>
    </target>

    <!-- Application should override -->
    <target name="javac.classpath"/>

</project>

